%%%%%%%%%%%%%%%%%%%%%
% Packages
%%%%%%%%%%%%%%%%%%%%%
\documentclass{report}  
\usepackage{amsmath}		
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{titlesec}
\usepackage[margin=1.0in]{geometry}
\usepackage{graphicx}
\usepackage{imakeidx}
\usepackage[bookmarks=true]{hyperref}
\usepackage{bookmark}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Nathan Esau <nesau@sfu.ca>}
\rhead{February 15th, 2015}

%\VignetteIndexEntry{User Guide}
%\VignetteDepends{}
%\VignetteKeywords{Vignettes}

%%%%%%%%%%%%%%%%%%%%%
% Format
%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\makeatother
\makeindex
\graphicspath{ {images/} }

%%%%%%%%%%%%%%%%%%%%%
% Start
%%%%%%%%%%%%%%%%%%%%%
\usepackage{Sweave}
\begin{document}\large{}
\input{user_guide-concordance}

\section*{Makeham's User Guide} 

This guide provides important details regarding the implementation of Makeham's Law in R.

\subsection*{Select Period}

An important implementation detail is regarding the select period. In all cases, a select period is assumed by default when using an actuarial function. This means that

\begin{itemize}
\item ${}_tp_{[x]}$ is implemented such that using a non-zero $s$ arugment results in ${}_tp_{[x]+s}$
\item $A_{[x]}$ is implemented such that using a non-zero $s$ arugment results in $A_{[x]+s}$
\item $\mu_{[x]}$ is implemented such that using a non-zero $s$ argument results in $\mu_{[x]+s}$ \\
\vdots
\end{itemize}

For instance, lets say that the select period is 2 and the value of $A_{20}$ is wanted. Calling \texttt{Ax(20,s=2)} actually gives the value $A_{[20]+2}$ and not $A_{20}$. Therefore, this value would have to be calculated as $A_{[18]+2}$ which is \texttt{Ax(18,s=2)}

To generalize the model to any select period, numerical integration was used in the implementation of several functions. For instance, the functions implementing ${}_tp_{x}$ and $A_{x}$ use numerical integration. Although this provides for flexibility in changing the model parameters, the disadvantages of such an approach are
\begin{itemize}
\item Running code such as building life tables takes noticeably longer when a large select period is used, such as $d=10$
\item In addition to a function using numerical integration potentially being slow, it is also less accurate than solving an integral before programming the function
\end{itemize}

\subsection*{Optional arguments}
Typically, as is the case with the $A_{[x]}$ function, rather than implementing new functions such as $\bar{A}_{[x]}$, these are optional parameters to the existing function. For instance, $\bar{A}_{[x]}$ can be calculate as \texttt{Ax(x,c=1)} where $c$ is an optional parameter indicating that a continuous expected present value should be calculated.

\begin{Schunk}
\begin{Sinput}
> library(makehams)
> head(createLifeTable(x=20))
\end{Sinput}
\begin{Soutput}
   x   l[x]+0   l[x]+1      lx+2 x+2
1 NA       NA       NA 100000.00  20
2 NA       NA       NA  99975.04  21
3 20 99995.08 99973.75  99949.71  22
4 21 99970.04 99948.40  99923.98  23
5 22 99944.63 99922.65  99897.79  24
6 23 99918.81 99896.43  99871.08  25
\end{Soutput}
\end{Schunk}

Another table that can be readily accessed is the insurance table.\footnote{note that the optional argument $s$ is the select already used. For $A[x]$ this is 0 and for $A[x]+d$ this is $d$}
\begin{Schunk}
\begin{Sinput}
> head(createInsuranceTable(x=20))
\end{Sinput}
\begin{Soutput}
   x       A[x]     A[x]+1       Ax+2     5E[x]   5E[x]+1     5Ex+2 x+2
1 20 0.04917546 0.05143193 0.05377599 0.7825547 0.7825077 0.7824769  22
2 21 0.05139908 0.05376425 0.05622182 0.7825368 0.7824872 0.7824536  23
3 22 0.05373095 0.05620990 0.05878622 0.7825168 0.7824641 0.7824275  24
4 23 0.05617607 0.05877410 0.06147464 0.7824942 0.7824381 0.7823980  25
5 24 0.05873967 0.06146230 0.06429274 0.7824688 0.7824089 0.7823650  26
6 25 0.06142720 0.06428015 0.06724641 0.7824403 0.7823761 0.7823278  27
\end{Soutput}
\end{Schunk}

\subsection*{Recursions}
The following recursion relationships hold
\begin{align*}
A_{[x]+d} &= A_{x+d} \\
A_{[x]+d-1} &= q_{[x]+d-1}v + p_{[x]+d-1}v(A_{x+d}) \\
A_{[x]+d-2} &= q_{[x]+d-2}v + p_{[x]+d-2}v(A_{[x]+d-1}) \\
\vdots \\
A_{[x]} &= q_{[x]}v + p_{[x]}v(A_{[x]+1})
\end{align*}

where $A_{x+d}$ can be calculated recursively using
\begin{equation}
A_{x} = vq_{x} + vp_{x}A_{x+1}
\end{equation}

Therefore the approach is to 
\begin{itemize}
\item Calculate $A_{x+d}$ for $x$ = $\omega - d - 1$ to $x - d$
\item Calculate $A_{[x]+d-t}$ for $t = 1$ to $d$ using $x$ = $\omega - d - 1$ to $x - d$
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%
% End
%%%%%%%%%%%%%%%%%%%%%
\end{document}
